# Readme

## Ex1

The code for the Caesar cipher using python is below:

```python
message = 'EVIRE'
for k in range(26):
    # output = chr((ord(message[0]) - 65 - k) % 26 + 97)
    output = ''
    for i in range(0, len(message)):
        output = output + chr((ord(message[i]) - 65 - k) % 26 + 97)
    print(output)
```



## Ex3

In the ex3.cpp, I implement the Extended Euclidean Algorithm and compare the value it calculated with the one generated by the build-in function "mpz_gcd()". Finally, we can find that the two values are the same.

Firstly, we should include the two header file for GMP:

```c++
#include <gmpxx.h>
#include <gmp.h>
```

Then, I generated the two 4096 bits numbers by implement two *for loops* and turn the binary numbers to "const char*" type:

```c++
string s1 = "", s2 = "";

srand(time(0));
for(int i = 0; i < 4096; i++) {
    if(rand() % 2 == 1){
        s1 += "1";
    }
    else s1 += "0";
}
const char *s11 = s1.c_str();
srand(rand() % 10);
for(int i = 0; i < 4096; i++) {
    if(rand() % 2 == 0){
        s2 += "0";
    }
    else s2 += "1";
}

const char* s22 = s2.c_str();
```

After that, I assign the two values to two variables, *a* and *b*:

```c++
mpz_init_set_str(a, s11, 2);
mpz_init_set_str(b, s22, 2);
```

Finally, I use the built-in function "mpz_gcd" to calculate the greatest common devisor of *a* and *b*:

```c++
mpz_gcd(c, a, b);
cout << "gcd using mpz_gcd(): " << endl;
gmp_printf("%Zd\n", c);
```

For the Extended Euclidean Algorithm, as the first state can be seen as a matrix $\begin{pmatrix} 1 & 0 & a \\ 0 & 1 & b \end{pmatrix}$ , then applying the normal Euclidean Algorithm, we can follow the change below:
$$
\begin{pmatrix}
	x & y & a\\
	r & s & a
\end{pmatrix}
\Rightarrow
\begin{pmatrix}
	r & s & b\\
	x-a\div b\times r & y-a\div b\times s & a\%b
\end{pmatrix}
$$
by setting the initial value of $x,\, y,\, r,\, s$ as $1, 0, 0, 1$, and repeat the algorithm until $b=0$.

Finally, the final *a* would be the value returned to show the greatest common devisor.

The complete code is below:

```c++
unsigned long int extended(mpz_t a,mpz_t b,mpz_t& x,mpz_t& y) {
    mpz_t r, s, t;
    mpz_init(r);
    mpz_init_set_str(s, "1", 10);
    mpz_init(t);
    mpz_set_ui(x, 1);
    mpz_set_ui(y, 0);

    //gmp_printf("%Zd %Zd %Zd %Zd %Zd %Zd %Zd\n", a, b, x, y, r, s, t);
    mpz_t temp;
    mpz_init(temp);
    while(mpz_cmp_ui(b, 0) != 0){
        mpz_set(t, r);
        mpz_fdiv_q(temp, a, b);
        mpz_mul(temp, temp, r);
        mpz_sub(r, x, temp);
        mpz_set(x, t);

        mpz_set(t, s);
        mpz_fdiv_q(temp, a, b);
        mpz_mul(temp, temp, s);
        mpz_sub(s, y, temp);
        mpz_set(y, t);

        mpz_set(t, b);
        mpz_fdiv_r(b, a, b);
        mpz_set(a, t);
    }

    unsigned long int answer = mpz_get_ui(a);

    mpz_clear(r);
    mpz_clear(s);
    mpz_clear(t);
    mpz_clear(temp);
    return answer;
}
```

The variable *t* serves as a buffer saving values and assign them to other variables.

In the main() function, we set gcd to be the value returned and print it:

```c++
unsigned long int gcd = extended(a, b, x, y);
cout << "gcd using Extended Euclidean Algorithm: " << endl;
cout << gcd << endl;
```

After running for hundreds of times, I find that the value generated by two different methods are always the same.

